###Análise de dados biológicos: Modelos lineares, generalizados e mistos
#Script produzido para a disciplina
#Autor: Prof. Sebastian Felipe Sendoya

###Aula 8 Construindo modelos clássicos no R 



#1. Construir a tabela com a unidade amostral como sendo a localidade ----
#(e não por amostra como na prática anterior)

#vamos usar a mesma tabela usada no scrpt anterior. Se o objeto xdat4 já existe
#na sua área de trabalho este paso não é nescesario
library(readxl)
xdat.amostra <-read_xlsx("dados_amostra.xlsx", sheet=1 ) #importa diretamente do arquivo excel
#conferir o cabeçalho da sua tabela:
head(xdat4)
str(xdat4)


#2. Importar a tabela que considera a unidade amostral como sendo a localidade ----
library(readxl)
xdatLocal <-read_xlsx("dados_local.xlsx", sheet=1 ) #importa diretamente do arquivo excel

#3. adicionar a riqueza média por amostra----
#este codigo nas proximas 4 linhas faz o calculo para cada localidade usando o 
#pacote dplyr. Veja help(dplyr) para mais detalhes
library(dplyr)
Tabelacurta<-xdat.amostra %>%
  group_by(Local) %>%
  summarize(MedRiqAmo=mean(RiqAmos),
            Med.MO = mean(MO))

xdatLocal$RiqAmost<-Tabelacurta$MedRiqAmo# junta a coluna criada no paso anterior com a nova tabela
xdatLocal$MOAmost<-Tabelacurta$Med.MO# junta a coluna criada no paso anterior com a nova tabela

#4. Produzir gráficos exploratórios
par(mfrow=c(1,2))#Configuração gráfica para permitir mostrar dois gráficos ao mesmo tempo
#use par(mfrow=c(1,1)) para voltar ao normal
##Scattplot relacionando Altitude com riqueza total
plot(xdatLocal$Alti, xdatLocal$RiquezaTotal, xlab= "Altitude (m)", ylab="Riqueza total no local")
##Scatterplot relacionando Temperatura com riqueza total
plot(xdatLocal$Temp, xdatLocal$RiquezaTotal, xlab="Temperatura (C)" , ylab= "Riqueza total no local")
#construa um coplot para ver possiveis efeitos de interações
coplot(xdatLocal$RiquezaTotal ~ xdatLocal$Alti|xdatLocal$Temp, pch=16,panel=panel.smooth, rows=1) #teste o argumento overlap=0

#com variaveis cataegoricas o correto é usar um boxplot para esta avaliação
#o boxplot apresenta as medianas, quartis e valores maximos e minimos dos seus dados
boxplot(xdatLocal$RiquezaTotal~ xdatLocal$Estado, main="Riqueza total")#riqueza total para cada Floresta
boxplot(xdatLocal$RiquezaTotal ~ xdatLocal$Protecao,main="Riqueza total")#riqueza Total para cada tipo de conservação

#Podemos usar uma tabela dinâmica para comparar a interação entre variaveis
RiqTotTab<-tapply(xdatLocal$RiquezaTotal, INDEX= list(xdatLocal$Estado, xdatLocal$Protecao), FUN=mean)
RiqTotTab

#Apartir desta tabela podemos visualizar as diferenças entre as combinações de categorias (Estado e Protecao)
par(mfrow=c(1,1))
#contruir um barplot para ver as diferenças de tamanho de efeito
barplot(RiqTotTab,beside=TRUE,xlab="EStado de Proteção", ylim= c(0,10))
legend(locator(1),legend=c("Primaria","Secundaria"),title="Estado sucessional",
       fill=c("black","lightgrey")) #permite adicionar a legenda na posição que desejar.
                                    #faça click na parte escolhida do grafico

###Aqui voltar para a presentação


#5. Análises: Modelos classicos
#5.1.comparando duas amostras

LocalPrim<- xdatLocal[xdatLocal$Estado %in% 'Primaria',]# filtra as linhas que tem o valor TRUE na coluna bar
LocalSecun<- xdatLocal[xdatLocal$Estado %in% 'Secundaria',]


#5.1.1. Testar homogeneidde de variancia----
var.test(RiquezaTotal~Estado, data= xdatLocal ) #mostra um test de F para ver se varianças são homogeneas
bartlett.test(RiquezaTotal~Estado, data= xdatLocal) #test de barlett para a riqueza total entre estados de sucessão
bartlett.test(RiquezaTotal~Protecao, data= xdatLocal) #test de barlett para a riqueza total entre niveis de protecao

#Teste de levenne
library(car)
leveneTest(RiquezaTotal ~ as.factor(Estado), data = xdatLocal)
leveneTest(RiquezaTotal ~ as.factor(Protecao), data = xdatLocal)




#5.1.2. testar normalidade----

#Avaliação gráfica
library(ggplot2)
ggplot(data=LocalPrim, aes(x=RiquezaTotal))+
  geom_histogram(aes(y = after_stat(density)), binwidth=1)+
  geom_density(lwd = 1.2,
               linetype = 2,
               colour = 2)

ggplot(data=LocalSecun, aes(x=RiquezaTotal))+
  geom_histogram(aes(y = after_stat(density)), binwidth=1)+
  geom_density(lwd = 1.2,
               linetype = 2,
               colour = 2)  


#Muitas vezes é feito diretamente com as variaveis
shapiro.test(LocalPrim$RiquezaTotal)
shapiro.test(LocalSecun$RiquezaTotal)
#porém o correto é fazer com os residuos do modelo
shapiro.test(resid(lm(RiquezaTotal~Estado, xdatLocal)))#test de normalidade, p maior a 0.05 significa que é normal
shapiro.test(resid(lm(RiquezaTotal~Protecao, xdatLocal)))#test de normalidade, p maior a 0.05 significa que é normal

#Avalião grafica de distribuição de residuos - Estado
Riq.esta<-lm(RiquezaTotal~Estado, xdatLocal)
names(Riq.esta)
Riq.esta$residuals
#Gráfico qqplot
qqnorm(Riq.esta$residuals)# comparar com distribuiÃ§Ã£o normal
qqline(Riq.esta$residuals)#comparar ocm ditribuiÃ§Ã£o normal

#Avalião grafica de distribuição de residuos - Protecao
Riq.prote<-lm(RiquezaTotal~Protecao, xdatLocal)
qqnorm(Riq.prote$residuals)# comparar com distribuiÃ§Ã£o normal
qqline(Riq.prote$residuals)#comparar ocm ditribuiÃ§Ã£o normal


#5.1.3. Comparação de medias visualmente----
#teste visual de comparação de medias. O "notch" permite avaliar se há dferenças. 

boxplot(RiquezaTotal~Estado,xlab="Estado sucessional",
        ylab="Riqueza total",col="lightblue", data= xdatLocal)

boxplot(RiquezaTotal~Estado, notch=T,xlab="Estado sucessional",  ylab="Riqueza total",col="lightblue", data= xdatLocal)

boxplot(RiquezaTotal~Protecao,notch=T,xlab="Estado sucessional",
        ylab="Riqueza total",col="lightblue", data= xdatLocal)

#5.1.4.Teste de t----
#uma vez que o modelo com temperatura foi normal podemos aplicar o test t
t.test(RiquezaTotal~Estado, data= xdatLocal)
t.test(RiquezaTotal~Protecao, data= xdatLocal)

#5.1.5.comparação não paramétrico: aplicamos em riqeuza ao não ser normal
wilcox.test(Temp~Estado, xdatLocal)


#5.1.6. Bootstraping
####as linhas seguintes são para testar uma hipotese pelo metodo de bootstraping
#Bootstraping é um metodo não parametrico que "cria" sua propria distribuição
#Util quando os dados não seguem a distribuição toerica



#funcao 1 (colocar nomes das varaives segundo seus dados)
stat <- function(data) {
  t.test <- t.test(RiquezaTotal ~ Protecao, data)$stat
  t.test
}
stat(xdatLocal)#testando se funciona

#funcao 2 (colocar variavel de saida segundo categorica dos seus dados)
rand.gen <- function(data, mle) {
    data$Protecao <- sample(data$Protecao, replace = T)
  data
}
rand.gen(xdatLocal)#testando se funciona

#agora utilizamos as duas funções junto com o pacote "boot"
library(boot)
Riqueza.boot<- boot(xdatLocal, stat, R=1000, sim="parametric",ran.gen = rand.gen )
print(Riqueza.boot)
plot(Riqueza.boot)
#Calculando a significancia (probabilidade) do valor de t observado dentro da nova dsitribuição
tval <- length(Riqueza.boot[Riqueza.boot$t >= abs(Riqueza.boot$t0)]) + 1
tval/(Riqueza.boot$R + 1)#mostra o valor de p para o bootstraping























#Fazendo o gráfico no ggplot2
library(ggplot2)
ggplot(data = xdatLocal, aes(x = Protecao, y = RiquezaTotal, color = Protecao)) + 
  labs(x = "Estado de conservação", 
       y = "Riqueza de espécies por amostra") +
  geom_boxplot(fill = c("chocolate4", "darkslategray"), color = "black", 
               outlier.shape = NA) +
  geom_jitter(shape = 16, position = position_jitter(0.1), 
              cex = 5, alpha = 0.7) +
  scale_color_manual(values = c("gray65", "black")) +
  theme_minimal()+
  theme(legend.position = "none")



