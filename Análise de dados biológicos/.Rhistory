modelRiq.1Nbin <- glm.nb(RiqAmos ~ (Estado+MO+SoloAmos)^2, data = DataM4, na.action = "na.fail")
#lista de Pacotes
library(MASS)
#4.1B. vamos testar a interação MO:SoloAmos
modelRiq.2NbinB <- update(modelRiq.1Nbin, .~. -MO:SoloAmos)
summary(modelRiq.2NbinB)
anova(modelRiq.1Nbin, modelRiq.2NbinB)
modelRiq.2Nbin <- update(modelRiq.1Nbin, .~. -Estado:SoloAmos)#Para alterar um modelo que já existe o sinal de -retira algo e +adiciona
summary(modelRiq.2Nbin)
anova(modelRiq.1Nbin, modelRiq.2Nbin)
#4.1B. vamos testar a interação MO:SoloAmos
modelRiq.2NbinB <- update(modelRiq.1Nbin, .~. -MO:SoloAmos)
anova(modelRiq.1Nbin, modelRiq.2NbinB)
#4.1C. vamos testar a interação Estado:SoloAmos
modelRiq.2NbinC <- update(modelRiq.1Nbin, .~. -Estado:MO)
anova(modelRiq.1Nbin, modelRiq.2NbinC)
####Uma opção melhor!!!
Anova(modelRiq.1Nbin)
#4.2. vamos testar tirando a interação Estado:SoloAmos e a interação MO:SoloAmos e continuar a selação a aprtir dai
modelRiq.3Nbin <- update(modelRiq.1Nbin, .~. -MO:SoloAmos - Estado:SoloAmos )
#vamor usar a funação Anova para ver testar MO:SoloAmos no novo modelo
Anova(modelRiq.3Nbin)
#4.3.  Resta testar os termos soltos, no caso SoloAmos
modelRiq.4Nbin <- update(modelRiq.3Nbin, .~. -SoloAmos )
anova(modelRiq.4Nbin, modelRiq.3Nbin)
Anova(modelRiq.3Nbin)
Anova(modelRiq.4Nbin)
#5. o melhor modelo adequado seria então:
summary(modelRiq.4Nbin)
Anova(modelRiq.4Nbin)
coef(modelRiq.4Nbin) #mostra os coeficientes do modelo
confint(modelRiq.4Nbin) #mostra os intervalos de confiança do modelo
library(ggplot2)
library(sjPlot)
library(jtools)
library(interactions)
install.packages("sjmisc")
install.packages("ggeffects")
library(broom.mixed)
library(dotwhisker)
library(sjmisc)
library(ggeffects)
#8. aqui o grafico de coeficientes brutos
dw <- dwplot(modelRiq.4Nbin, show_intercept = TRUE)
dw
print(dw+geom_vline(xintercept=0,lty=2))
# Ver AICc Pelo pacote MuMIn
library(MuMIn)
Multimodel.log2<-dredge(model.glm.gamma.log2)
# Ver AICc Pelo pacote MuMIn
library(MuMIn)
Multimodel.log2<-dredge(model.glm.gamma.log2)
model.glm.gamma.log2 <- glm(antspeed_cm.s~(colonyID+substrate+seedweight_mg+substrate:seedweight_mg),
data = AntSpeed, family = Gamma(link="log"),na.action = na.omit)
Multimodel.log2 <- dredge(model.glm.gamma.log2)
model.glm.gamma.log2 <- glm(antspeed_cm.s~(colonyID+substrate+seedweight_mg+substrate:seedweight_mg),
data = AntSpeed, family = Gamma(link="log"),na.action = "na.omit")
Multimodel.log2 <- dredge(model.glm.gamma.log2)
options(na.action = "na.omit")
Multimodel.log2 <- dredge(model.glm.gamma.log2)
model.glm.gamma.log2 <- glm(antspeed_cm.s~(colonyID+substrate+seedweight_mg+substrate:seedweight_mg),
data = AntSpeed,options(na.action = "na.omit"),family = Gamma(link="log"))
model.glm.gamma.log2 <- glm(antspeed_cm.s~(colonyID+substrate+seedweight_mg+substrate:seedweight_mg),
data = AntSpeed, na.action = "na.omit",family = Gamma(link="log"))
Multimodel.log2 <- dredge(model.glm.gamma.log2)
options(na.action = "na.omit")
Multimodel.log2 <- dredge(model.glm.gamma.log2)
model.glm.gamma.log2 <- glm(antspeed_cm.s~(colonyID+substrate+seedweight_mg+substrate:seedweight_mg),
data = AntSpeed, na.action = "na.fail",family = Gamma(link="log"))
Multimodel.log2 <- dredge(model.glm.gamma.log2)
Multimodel.log2
model.sel(Multimodel.log2)
#7. odds ratio / effect size
exp(cbind(coef(modelRiq.4Nbin), confint(modelRiq.4Nbin)))
coef(model.glm.gamma.log2)
confint(model.glm.gamma.log2)
# odds ratio / effect size
exp(cbind(coef(model.glm.gamma.log2), confint(model.glm.gamma.log2)))
#para comaprar tamanho de efeito corretamente entre preditores é necessário um apadronização, isto siginifica que cada variavel seja transformada para ter média 0 e desvio padrão 1
#O pacote performance faz isso "a posteriori" re-ajustando os modelos, mas vc pode padronizar as variavel antes de construir o modelo.
library(effectsize)
effecsize.model.4.Nbin.basic<- effectsize(modelRiq.4Nbin, method = "basic")
effecsize.model.4.Nbin.basic
effecsize.model.4.Nbin<- effectsize(modelRiq.4Nbin, method = "refit")#metodo refit não padroniza os fatores. émelhor usar basic nesses casos ou padronizar antes de rodar o modelo.
effecsize.model.glm.basic<- effectsize(model.glm.gamma.log2, method = "basic")
effecsize.model.glm.basic
effecsize.glm.refit<- effectsize(model.glm.gamma.log2, method = "refit")#metodo refit não padroniza os fatores. émelhor usar basic nesses casos ou padronizar antes de rodar o modelo.
effecsize.glm.refit
effecsize.model.4.Nbin<- effectsize(modelRiq.4Nbin, method = "refit")#metodo refit não padroniza os fatores. émelhor usar basic nesses casos ou padronizar antes de rodar o modelo.
#lista de Pacotes
library(MASS)
effecsize.model.4.Nbin<- effectsize(modelRiq.4Nbin, method = "refit")#metodo refit não padroniza os fatores. émelhor usar basic nesses casos ou padronizar antes de rodar o modelo.
effecsize.model.4.Nbin
# aqui o grafico de coeficientes brutos
dw.glm <- dwplot(model.glm.gamma.log2, show_intercept = TRUE)
library(ggplot2)
library(sjPlot)
library(jtools)
library(interactions)
library(broom.mixed)
library(dotwhisker)
library(sjmisc)
library(ggeffects)
# aqui o grafico de coeficientes brutos
dw.glm <- dwplot(model.glm.gamma.log2, show_intercept = TRUE)
dw.glm
print(dw.glm+geom_vline(xintercept=0,lty=2))
#aqui o grafic de coeficientes padronizados, com escala do exixo logaritmica
plot_summs(model.glm.gamma.log2, scale = T, exp = TRUE)
#aqui os coeficientes já tranformados
plot_model(modelRiq.4Nbin, show.values = T, value.offset = 0.2)
#aqui os coeficientes já tranformados
plot_model(model.glm.gamma.log2, show.values = T, value.offset = 0.2)
#9. grafico final do modelo
interactions::interact_plot(modelRiq.4Nbin, pred=MO, modx=Estado,
plot.points=T, interval=T, outcome.scale="response")
model.glm.gamma.log2
#Ver os resultados brutos:
#9. grafico final do modelo
interactions::interact_plot(model.glm.gamma.log2, pred=seedweight_mg, modx=substrate,
plot.points=T, interval=T, outcome.scale="response")
#Ver os resultados brutos:
#9. grafico final do modelo
interactions::interact_plot(model.glm.gamma.log3, pred=seedweight_mg, modx=substrate,
plot.points=T, interval=T, outcome.scale="response")
library(glmmTMB)
library(glmmTMB)
riqmodel.TMB.1<-glmmTMB(RiqAmos ~ Estado + MO + Estado:MO, data = DataM4,
family = "nbinom1")
riqmodel.TMB.Zero<-glmmTMB(RiqAmos ~ Estado + MO + Estado:MO, data = DataM4,
family = "nbinom1", ziformula = ~Estado + MO)
AICctab(riqmodel.TMB.1, riqmodel.TMB.Zero)
library(bbmle)
AICctab(riqmodel.TMB.1, riqmodel.TMB.Zero)
check_overdispersion(riqmodel.TMB.Zero)
library(performance)
library(see)
library(qqplotr)
check_overdispersion(riqmodel.TMB.Zero)
library(DHARMa)#pacote para analisar ajuste e premisas de modelos
testDispersion(riqmodel.TMB.Zero)# este test ajuda a reforçaro dito
aveiaid.zero <-simulateResiduals(riqmodel.TMB.Zero, plot = T)
check_model(riqmodel.TMB.Zero)
Anova(riqmodel.TMB.Zero)
#4. seleção dos modelos
library(car)
Anova(riqmodel.TMB.Zero)
#Ver os resultados brutos:
#9. grafico final do modelo
interactions::interact_plot(model.glm.gamma.log2, pred=seedweight_mg, modx=substrate,
plot.points=T, interval=T, outcome.scale="response")
install.packages("AER")
#lista de Pacotes
library(MASS)
library(vcd)
library(readxl)
library(ggplot2)
library(performance)
library(AER)
library(car)
library(effectsize)
library(sjPlot)
library(jtools)
library(interactions)
library(broom.mixed)
library(dotwhisker)
library(sjmisc)
library(ggeffects)
#Carregando os dados
library(readxl)
DataFlores <-read_xlsx("exemplo_flores.xlsx", sheet=1) #importa diretamente do arquivo excel
#conferir o cabeçalho da sua tabela:
head(DataFlores)
str(DataFlores)
#1. Fazer avaliação geral.
plot(DataFlores)
#1.1. Vamos criar duas colunas especificas, uma para calcular diretamente a proporção (pf)
#e outra (PropoF)em que vamos relacionar (com o cbind) quantas plantas produciram flores ("florered")
#com quantas não produziram ("number"-"florered")
DataFlores$pf <- DataFlores$flowered/DataFlores$number
DataFlores$PropoF <- cbind(DataFlores$flowered,DataFlores$number-DataFlores$flowered)
#1.2 Graficos especificos avaliando a proporção
plot(pf~dose, data= DataFlores, xlab="Dose",
ylab="Proportion flowered")
DataFlores
#1.2 Graficos especificos avaliando a proporção
plot(pf~dose, data= DataFlores, xlab="Dose",
ylab="Proportion flowered")
library(ggplot2)
ggplot(DataFlores,aes(pf,dose,group=variety))+#geom_point()+
geom_jitter(aes(shape=variety, color= variety), alpha=0.8,)+
theme_minimal()
ggplot(DataFlores,aes(dose,pf,group=variety))+#geom_point()+
geom_jitter(aes(shape=variety, color= variety), alpha=0.8,)+
theme_minimal()
ggplot(DataFlores,aes(dose,pf,group=variety))+#geom_point()+
geom_jitter(aes(shape=variety, color= variety),size=3, alpha=0.8,)+
theme_minimal()
boxplot(pf~variety, data= DataFlores, xlab="Variedade de planta", ylab="Proportion flowered")
#2.1. Os testes de ajuste usam relação de verosimilhança comparando com a ditribuição teorica
#De forma geral entre menor o vaor de X2 e menor o p melhor
library(vcd)
fitbin <- goodfit(DataFlores$PropoF, type= "binomial")
summary(fitbin)
rootogram(fitbin)
#3. neste caso vamos diretamente ao modelo
modelFlor.bin.1 <- glm(PropoF ~ variety*dose, data = DataFlores, family = binomial, na.action = "na.fail")
plot(modelFlor.bin.1)
#3.1.PARA CHECAR MULTICOLINEARIDADE
library(performance)
modelFlor.bin.2 <- update(modelFlor.bin.1, .~. -variety:dose )
Mod.colinear.flo <- check_collinearity(modelFlor.bin.2)
plot(Mod.colinear.flo)
#3.2PARA CHECAR outliers
Mod.Outlier.flo <- check_outliers(modelFlor.bin.1)
Mod.Outlier.flo
plot(Mod.Outlier.flo)#caso haja outliers aqui pode visualizar eles
#3.3.overdispersion
#eviter valores maiores de 1
#uma alternativa para faores de overdispersion muito maiores que 1 é usar family= quasipoisson
check_overdispersion(modelFlor.bin.1)
#3.4.parachecar uniformidade
plot(simulate_residuals(modelFlor.bin.1))
check_residuals(modelFlor.bin.1)
library(DHARMa)#pacote para analisar ajuste e premisas de modelos
testDispersion(modelFlor.bin.1)# este test ajuda a reforçaro dito
aveiaid <-simulateResiduals(modelFlor.bin.1, plot = T)
testUniformity(modelFlor.bin.1)
DataFlores[10,]
modelFlor.bin.1.out <- glm(PropoF ~ variety*dose, data = DataFlores[-c(10),],
family = binomial, na.action = "na.fail")
plot(modelFlor.bin.1.out)
testDispersion(modelFlor.bin.1.out)
Mod.Outlier.flo.out <- check_outliers(modelFlor.bin.1.out)
plot(Mod.Outlier.flo.out)
aveiaid <-simulateResiduals(modelFlor.bin.1.out, plot = T)
testUniformity(modelFlor.bin.1.out)
#3.1.inicia a seleção de modelos
library(car)
Anova(modelFlor.bin.1.out)
modelFlor.bin.2 <- update(modelFlor.bin.1.out, .~. -variety:dose )
anova(modelFlor.bin.1.out, modelFlor.bin.2, test="Chisq") #perceva que devemos indicar o tipo de test a ser aplicado (qui cuadrado)
#3.3. outras abordagens de seleção
library(car)
summary(modelFlor.bin.1.out)
plot(modelFlor.bin.1.out)
#Partição da deviance (analogo a variancia)
Anova(modelFlor.bin.1.out)
#4. odds ratio / effect size
#coeficintes transformados
exp(cbind(coef(modelFlor.bin.1.out), confint(modelFlor.bin.1.out)))
#coeficientes padronizados
library(effectsize)
effecsize.model.flor.qua1<- effectsize(modelFlor.bin.1.out, method = "refit")
effecsize.model.flor.qua1
effecsize.model.flor.qua1<- effectsize(modelFlor.bin.1.out, method = "basic")
effecsize.model.flor.qua1
library(ggplot2)
library(sjPlot)
library(jtools)
library(interactions)
library(broom.mixed)
library(dotwhisker)
library(sjmisc)
library(ggeffects)
predictions.flo<-ggpredict(modelFlor.bin.1, type = "fixed",
terms = c("dose [0:40]","variety"))
ls(predictions.flo)
predictions.flo
predictions.flo$group
ggplot(DataFlores, aes(x = dose, y = pf))+
#geom_point(aes(size = carcasses, colour = factor(radius)), position = position_dodge(.3))+
geom_jitter(aes(x = dose, y = pf, size = number, colour = factor(variety)), alpha=0.9, width = 0.3)+
scale_size_continuous(range = c(1, 5))+
#scale_color_manual(values = c("#173F5f", "#3CAEA3", "#ED5538"))+
scale_colour_brewer(palette = "Set1")+
geom_line(data=predictions.flo, aes(x = x, y = predicted, colour = factor(group))) +
#geom_path()+
xlab("Dose")+ylab("Proportion flowered")+ ggtitle("")+theme_minimal()+
theme(
legend.position="right",
plot.title = element_text(size=11),
axis.line.y = element_line(size = 1, colour = 1),
axis.line.x = element_line(size = 1, colour = 1),
axis.title.x = element_text(size = 15),
axis.title.y = element_text(size = 15),
axis.text.x = element_text(size = 13),
)
#5.1. grafico de coeficientes brutos
plot_summs(modelFlor.bin.1.out, scale = T)
#5.1.grafico com coef padronizados
plot_model(modelFlor.bin.1.out, show.values = T, value.offset = .3,type = "std" )
#5.1.grafico com coef transformados
plot_model(modelFlor.bin.1.out, show.values = T, value.offset = .2)
library(lme4)
library(MASS)
library(car)
library(afex)
library(Rcpp)
library(Matrix)
library(readxl)
library(lmerTest)
library(performance)
library(see)
library(qqplotr)
library(DHARMa)
library(effectsize)
library(ggplot2)
library(sjPlot)
library(jtools)
library(interactions)
library(broom.mixed)
library(dotwhisker)
library(sjmisc)
library(ggeffects)
Flores.Nec <-read_xlsx("exemplo_mistos.xlsx", sheet=1) #importa diretamente do arquivo excel
Flores.Nec$Individuo<- factor(Flores.Nec$Individuo) #transforma a variavel em um fator
Flores.Nec$Nectar <- as.numeric(Flores.Nec$Nectar)
Flores.Nec$Sexo <- as.factor(Flores.Nec$Sexo)
Flores.Nec$Horario <- as.numeric(Flores.Nec$Horario)
lm.out.1 <- lm(Nectar~Horario*Sexo, data=Flores.Nec) #cria modelos linear simples
lm.out.2 <- lm(Nectar~Horario+Sexo, data=Flores.Nec) #cria modelos linear simples
install.packages("lme4")
install.packages("lmerTest")
#2. construção do modelo com os interceptos aleatorios
library(lme4)
library(lmerTest)
#2.1 testando efeito s aleatorios
flor.lme4.1 <- lmer(Nectar~Horario*Sexo+ (1|Individuo), data = Flores.Nec, REML=FALSE)
summary(flor.lme4.1) #Mostra resultados
anova(flor.lme4.1,lm.out.1, test='Chisq') #comparação de modelos
coef(flor.lme4.1)
#2.2. testando efeitos fixos
flor.lme4.2 <- lmer(Nectar~Horario +Sexo+ (1|Individuo), data = Flores.Nec, REML=FALSE) #Duas varaiveis
summary(flor.lme4.2) #Comparar resultados com modelo anterior
anova(flor.lme4.1,flor.lme4.2, test='Chisq') #comparação de modelos
Anova(flor.lme4.2)
coef(flor.lme4.1)# Ver os coeficientes para cada individuo
#Comparaçao de distribuiçãocom pacote perfomance
library(performance)
library(see)
library(qqplotr)
anova(flor.lme4.1,lm.out.1, test='Chisq') #comparação de modelos
Anova(flor.lme4.2)
library(broom.mixed)
library(interactions)
library(dotwhisker)
library(ggeffects)
Anova(flor.lme4.2)
library(car)
Anova(flor.lme4.2)
coef(flor.lme4.2)# Ver os coeficientes para cada individuo
coef(flor.lme4.1)
library(ggeffects)
predictions.flower1<-ggpredict(flor.lme4.2, type ="re" ,
terms = c( "Horario", "Sexo", "Individuo"))
ls(predictions.flower1)
predictions.flower1
predictions.flower1$group
predictions.flower1$facet
predictions.flower1$x
plot(predictions.flower1, ci=T)
predictions.flower2<-ggpredict(flor.lme4.2, type ="re" , terms = c("Horario", "Individuo"))
plot(predictions.flower2, color = c(1:10))
predictions.flower2$group
predictions.flower3<-ggpredict(flor.lme4.2, type ="re" , terms = c("Horario", "Sexo", "Individuo"))
plot(predictions.flower3)
predictions.flower3<-ggpredict(flor.lme4.2, type ="re" , terms = c("Sexo", "Individuo"))
plot(predictions.flower3)
plot(predictions.flower3, colors = c(1:10))
#2.3. Mas os indivduos não podem variar ao longo do tempo? Inclinação aleatoria
flor.lme4.3 <- lmer(Nectar~Horario*Sexo+ (Horario|Individuo), data = Flores.Nec, REML=FALSE) #Duas varaiveis
check_model(flor.lme4.3)
check_outliers(flor.lme4.3)
check_heteroscedasticity(flor.lme4.3)
testDispersion(flor.lme4.3)# este test ajuda a reforçaro dito
summary(flor.lme4.3) #Comparar resultados com modelo anterior
anova(flor.lme4.1,flor.lme4.3, test='Chisq') #compara'c~ao de modelos
aveiaid <-simulateResiduals(flor.lme4.3, plot = T)
library(DHARMa)
aveiaid <-simulateResiduals(flor.lme4.3, plot = T)
summary(flor.lme4.3) #Comparar resultados com modelo anterior
anova(flor.lme4.1,flor.lme4.3, test='Chisq') #compara'c~ao de modelos
flor.lme4.4 <- lmer(Nectar~Horario+Sexo+ (Horario|Individuo), data = Flores.Nec, REML=FALSE) #Duas varaiveis
anova(flor.lme4.3,flor.lme4.4, test='Chisq')
anova(flor.lme4.3,flor.lme4.4, test='Chisq')
predictions.flower4<-ggpredict(flor.lme4.3, type ="re" , terms = c("Horario", "Individuo"))
plot(predictions.flower4, color = c(1:10), show_data = F)
predictions.flower5<-ggpredict(flor.lme4.3, type ="re" , terms = c("Horario", "Sexo", "Individuo"))
plot(predictions.flower5, show_data = F )
plot(predictions.flower5, show_data = T )
ggplot(Flores.Nec,  aes(x=Horario, y=Nectar)) +
geom_jitter(aes(x=Horario, y=Nectar, color=Individuo), size=2, alpha=0.9, width = 0.1) +
geom_line(predictions.flower5, mapping= aes(x =  x, y = predicted, colour = factor(group), group=factor(group)))+
#scale_color_brewer(palette="Paired")+
theme_minimal() +
theme(
legend.position="none",
plot.title = element_text(size=11)) +
xlab("Horario de coleta")+
ylab("Nectar coletado")+
theme(
plot.title = element_text(size=11),
axis.line.y = element_line(size = 1, colour = 1),
axis.line.x = element_line(size = 1, colour = 1),
axis.title.x = element_text(size = 15),
axis.title.y = element_text(size = 15),
axis.text.x = element_text(size = 13),
)
ggplot(Flores.Nec,  aes(x=Horario, y=Nectar)) +
geom_jitter(aes(x=Horario, y=Nectar, color=Individuo), size=2, alpha=0.9, width = 0.1) +
geom_line(predictions.flower5, mapping= aes(x =  x, y = predicted, colour = factor(facet), group=factor(group)))+
#scale_color_brewer(palette="Paired")+
theme_minimal() +
theme(
legend.position="none",
plot.title = element_text(size=11)) +
xlab("Horario de coleta")+
ylab("Nectar coletado")+
theme(
plot.title = element_text(size=11),
axis.line.y = element_line(size = 1, colour = 1),
axis.line.x = element_line(size = 1, colour = 1),
axis.title.x = element_text(size = 15),
axis.title.y = element_text(size = 15),
axis.text.x = element_text(size = 13),
)
View(xdat1)
#vamos usar a mesma tabela usada no scrpt anterior. Se o objeto xdat4 já existe
#na sua área de trabalho este paso não é nescesario
library(readxl)
xdat.local <-read_xlsx("dados_local.xlsx", sheet=1 ) #importa diretamente do arquivo excel
View(xdat.local)
#3. adicionar a riqueza média por amostra----
#este codigo nas proximas 4 linhas faz o calculo para cada localidade usando o
#pacote dplyr. Veja help(dplyr) para mais detalhes
library(dplyr)
Tabelacurta<-xdat.amostra %>%
group_by(Local) %>%
summarize(MedRiqAmo=mean(RiqAmos),
Med.MO = mean(MO))
xdatLocal$RiqAmost<-Tabelacurta$MedRiqAmo# junta a coluna criada no paso anterior com a nova tabela
Tabelacurta<-xdat1 %>%
group_by(Local) %>%
summarize(MedRiqAmo=mean(RiqAmos),
Med.MO = mean(MO))
Tabelacurta<-xdat1 %>%
group_by(Local) %>%
summarize(MedRiqAmo=mean(RiqAmos))
xdatLocal$RiqAmost<-Tabelacurta$MedRiqAmo# junta a coluna criada no paso anterior com a nova tabela
xdat.local$RiqAmost<-Tabelacurta$MedRiqAmo# junta a coluna criada no paso anterior com a nova tabela
#4. Produzir gráficos exploratórios
par(mfrow=c(1,2))#Configuração gráfica para permitir mostrar dois gráficos ao mesmo tempo
#use par(mfrow=c(1,1)) para voltar ao normal
##Scattplot relacionando Altitude com riqueza total
plot(xdatLocal$Alti, xdatLocal$RiquezaTotal, xlab= "Altitude (m)", ylab="Riqueza total no local")
#use par(mfrow=c(1,1)) para voltar ao normal
##Scattplot relacionando Altitude com riqueza total
plot(xdat.local$Alti, xdat.local$RiquezaTotal, xlab= "Altitude (m)", ylab="Riqueza total no local")
##Scatterplot relacionando Temperatura com riqueza total
plot(xdat.local$Temp, xdat.local$RiquezaTotal, xlab="Temperatura (C)" , ylab= "Riqueza total no local")
View(xdat.local)
#construa um coplot para ver possiveis efeitos de interações
coplot(xdatLocal$RiquezaTotal ~ xdatLocal$Alti|xdatLocal$Temp, pch=16,panel=panel.smooth, rows=1) #teste o argumento overlap=0
#construa um coplot para ver possiveis efeitos de interações
coplot(xdat.local$RiquezaTotal ~ xdat.local$Alti|xdatLocal$Temp, pch=16,panel=panel.smooth, rows=1) #teste o argumento overlap=0
#construa um coplot para ver possiveis efeitos de interações
coplot(xdat.local$RiquezaTotal ~ xdat.local$Alti|xdat.local$Temp, pch=16,panel=panel.smooth, rows=1) #teste o argumento overlap=0
boxplot(RiquezaTotal~Estado,xlab="Estado sucessional",
ylab="Riqueza total",col="lightblue", data= xdatLocal)
boxplot(RiquezaTotal~Estado,xlab="Estado sucessional",
ylab="Riqueza total",col="lightblue", data= xdat.local)
boxplot(RiquezaTotal~Estado, notch=T,xlab="Estado sucessional",  ylab="Riqueza total",col="lightblue", data= xdat.local)
#5.1.5.comparação não paramétrico: aplicamos em riqeuza ao não ser normal
wilcox.test(Temp~Estado, xdatLocal)
#5.1.5.comparação não paramétrico: aplicamos em riqeuza ao não ser normal
wilcox.test(Temp~Estado, xdat.local)
ggplot(data = xdat.local, aes(x = Protecao, y = RiquezaTotal, color = Protecao)) +
labs(x = "Estado de conservação",
y = "Riqueza de espécies por amostra") +
geom_boxplot(fill = c("chocolate4", "darkslategray"), color = "black",
outlier.shape = NA) +
geom_jitter(shape = 16, position = position_jitter(0.1),
cex = 5, alpha = 0.7) +
scale_color_manual(values = c("gray65", "black")) +
theme_minimal()+
theme(legend.position = "none")
#Fazendo o gráfico no ggplot2
library(ggplot2)
ggplot(data = xdat.local, aes(x = Protecao, y = RiquezaTotal, color = Protecao)) +
labs(x = "Estado de conservação",
y = "Riqueza de espécies por amostra") +
geom_boxplot(fill = c("chocolate4", "darkslategray"), color = "black",
outlier.shape = NA) +
geom_jitter(shape = 16, position = position_jitter(0.1),
cex = 5, alpha = 0.7) +
scale_color_manual(values = c("gray65", "black")) +
theme_minimal()+
theme(legend.position = "none")
#1.1. Avaliação inicial: vamos relacionar a Riqueza total com a temperatura
plot(RiquezaTotal~Temp, data= xdat.local, xlab="Temperatura (Cº)",
ylab="Riqueza total no local")
plot(Temp.lm.tot)
dev.off() # volta a configuração dos gráficos para o formato padrão
plot(Temp.lm.tot)
#1.6. vamos graficar os residuos do modelo
plot(RiquezaTotal~Temp, data= xdat.local, xlab="Temperatura (Cº)",
ylab="Riqueza total no local", xlim=c(0, 50), ylim=c(0, 13))
#agora vamos mostrar graficamente os residuos
for (i in 1:26){
lines(c(xdatLocal$Temp[i],xdatLocal$Temp[i]),c(xdatLocal$RiquezaTotal[i],fitted.Temp.tot[i]),col="red")
}
